#!/bin/sh
#
# perfdiagnose
#
# DESCRIPTION
#  Collects performance data.
#
# HISTORY
#  2010-11  - Mike Kerzhner  - Created
#  2012-04  - Paul Salzman   - Updated
#
# Copyright (c) 2010 Apple Inc. All rights reserved.

ALLMEMORY=/usr/bin/allmemory
AWK=/usr/bin/awk
BOOTCACHECONTROL=/usr/sbin/bootcachecontrol
CAT=/bin/cat
CGDEBUG=/usr/local/bin/cgdebug
CP=/bin/cp
DATE=/bin/date
DDT=/usr/local/bin/ddt
DF=/bin/df
DIG=/usr/bin/dig
DISKUTIL=/usr/sbin/diskutil
ECHO=/bin/echo
EGREP=/usr/bin/egrep
FS_USAGE=/usr/bin/fs_usage
GPT=/usr/sbin/gpt
GREP=/usr/bin/grep
HEAD=/usr/bin/head
HEAP=/usr/bin/heap
IFCONFIG=/sbin/ifconfig
IOREG=/usr/sbin/ioreg
IPCONFIG=/usr/sbin/ipconfig
KEXTSTAT=/usr/sbin/kextstat
KILL=/bin/kill
KILLALL=/usr/bin/killall
LEAKS=/usr/bin/leaks
LSOF=/usr/sbin/lsof
MKDIR=/bin/mkdir
MOUNT=/sbin/mount
NETSTAT=/usr/sbin/netstat
NULL=/dev/null
ODUTIL=/usr/bin/odutil
OSASCRIPT=/usr/bin/osascript
PMSET=/usr/bin/pmset
PRINTF=/usr/bin/printf
PS=/bin/ps
READ=/usr/bin/read
RM=/bin/rm
RUBY=/usr/bin/ruby
SCUTIL=/usr/sbin/scutil
SH=/bin/sh
SLEEP=/bin/sleep
SORT=/usr/bin/sort
SPINDUMP=/usr/sbin/spindump
SW_VERS=/usr/bin/sw_vers
SYMSTACKS=/usr/sbin/symstacks.rb
SYSCTL=/usr/sbin/sysctl
SYSTEM_PROFILER=/usr/sbin/system_profiler
TAIL=/usr/bin/tail
TALAGENT=/System/Library/CoreServices/talagent
TAR=/usr/bin/tar
TOP=/usr/bin/top
TR=/usr/bin/tr
TRACE=/usr/bin/trace
VMMAP=/usr/bin/vmmap
WC=/usr/bin/wc
WHO=/usr/bin/who
XARGS=/usr/bin/xargs
ZPRINT=/usr/bin/zprint

PROCESS_MODE=0
# If we are being invoked from another diagnostic tool, we will not display the legal notice. The legal notice should have already been displayed by the "master" tool.
TOOL_MODE=0
QUICK_MODE=0

# For stackshot mode (invoked with -s flag)
# =========================================
STACKSHOT_MODE=0
symbolication_command=""
symtrace_file=""
# =========================================

# For thorough mode (enabled with touch /var/tmp/.thoroughsysdiagnose)
# =========================================
THOROUGH_MODE=0

script_name="perfdiagnose"
temp_directory="/var/tmp/"
process_identifier="$1"

usage() {
    {
        "${ECHO}" "${script_name} version: 1.2.2"
        "${ECHO}" "USAGE: ${script_name} [-h] [-f result_directory] [process_name | pid]"
        "${ECHO}" "          -h                      Display this help"
        "${ECHO}" "          -f result directory     Specify the directory where results will be stored."
        "${ECHO}" "          [process_name | pid]    If a single process appears to be slowing down the system," 
        "${ECHO}" "                                  passing in the process name or ID as the argument gathers" 
        "${ECHO}" "                                  addition process-specific diagnostic data."
        "${ECHO}"
        "${ECHO}" "DESCRIPTION:"
        "${ECHO}" "  ${script_name} gathers system diagnostic information helpful in investigating system performance issues." 
        "${ECHO}" "  A great deal of information is harvested, spanning system state and configuration. The data is stored /var/tmp directory." 
        "${ECHO}" "  ${script_name} can be triggered upon pressing a special key chord; this is currently Control-Option-Command-Shift-Period."        
        "${ECHO}" "WHAT ${script_name} COLLECTS:"
        "${ECHO}" "  - A spindump of the system"
        "${ECHO}" "  - Several seconds of fs_usage ouput"
        "${ECHO}" "  - Several seconds of top output"
        "${ECHO}" "  - Data about kernel zones"
        "${ECHO}" "  - Status of loaded kernel extensions"
        "${ECHO}" "  - Resident memory usage of user processes"
        "${ECHO}" "  - All system logs, kernel logs, opendirectory log, windowserver log, and log of power management events"
        "${ECHO}" "  - A System Profiler report"
        "${ECHO}" "  - All spin and crash reports"
        "${ECHO}" "  - Disk usage information"
        "${ECHO}" "  - I/O Kit registry information"
        "${ECHO}" "  - Network status"
        "${ECHO}" "  - If a specific process is supplied as an argument: a list of malloc-allocated buffers in the process's heap is collected"
        "${ECHO}" "  - If a specific process is supplied as an argument: data about unreferenced malloc buffers in the process's memory is collected"
        "${ECHO}" "  - If a specific process is supplied as an argument: data about the virtual memory regions allocated in the process"


    } >&2
    exit 1
}

legal() {
    {
        "${ECHO}" "This diagnostic tool generates files that allow Apple to investigate issues with your computer and help Apple to improve its products. \
The generated files may contain some of your personal information, which may include, but not be limited to, the serial number or similar unique number for \
your device, your user name, or your computer name. The information is used by Apple in accordance with its privacy policy (www.apple.com/privacy) and is not \
shared with any third party. By enabling this diagnostic tool and sending a copy of the generated files to Apple, you are consenting to Apple’s use of the content of such files."

        "${ECHO}" ""
        "${ECHO}" "Please press 'Enter' to continue"
    }

}

check_sudo() {
    # Force the user to enter the sudo password so that tools requiring sudo do not prompt the user for a password
    if [[ $EUID -ne 0 ]]; then
        "${ECHO}" "You need to enter your administrator password to run ${script_name}." 1>&2
        exec sudo ${script_name} $@
    fi
}

# If the results directory is provided, check that its a valid path. Also format the path to have a slash as the last character.
set_output_directory(){
    {
    if [ "$1" = "" ]
    then
        "${ECHO}" "Error: no path is provided" 1>&2
        "${ECHO}" ""
        usage
    fi

    temp_directory="$1"
    # Check that the provided path is a valid directory.
    if [ ! -d "${temp_directory}" ]
    then
        "${ECHO}" "The path provided with the -f option is not a valid directory." 1>&2
        "${ECHO}" "" 
        exit 1
    fi

    # Convert relative to global path.
    cd "${temp_directory}"
    temp_directory=`pwd`/
    }
}

copy_dir_if_present() {
    srcdir="${1}"
    destpath="${2}"
    if [ -d ${srcdir} ]
    then
	"${CP}" "-R" "-p" ${srcdir} ${destpath} 2>> ${tools_output}
    else
	"${ECHO}" "${srcdir} not found. Skipping." >> ${tools_output} 2>&1
    fi
}

copy_file_if_present() {
    srcfile="${1}"
    destpath="${2}"
    if [ -f ${srcfile} ]
    then
	"${CP}" "-p" ${srcfile} ${destpath} 2>> ${tools_output}
    else
	"${ECHO}" "${srcfile} not found. Skipping." >> ${tools_output} 2>&1
    fi
}

copy_files_if_present() {
    srcfiles="${1}"
    destpath="${2}"
    for file in ${srcfiles}
    do
        copy_file_if_present ${file} ${destpath}
    done
}

copy_files_from_directory_if_present() {
    src_directory="${1}"
    srcfiles="${2}"
    destpath="${3}"
    for file in ${srcfiles}
    do
        copy_file_if_present "${src_directory}/${file}" ${destpath}
    done
}



# We only gather crash and spin reports for the current build in order to not bloat our results
copy_reports_for_current_build(){
    {

    input_directory="$1"
    output_directory="$2"
    current_build="$3"
    reports=${input_directory}/*
    for report in $reports
    do
        # We count on the build number being stated within the first ten lines of a spin/crash report 
        is_current_build=$( "${HEAD}" -n 10 "${report}" 2>> ${tools_output} | "${GREP}" "${current_build}" )
        if [ "$is_current_build" != "" ]
        then
            "${CP}" "-p" "${report}" "${output_directory}"
        fi
    done
    }

}

suggestion() {
    {
        "${ECHO}" "Helpful Hint: If a single process appears to be slowing down the system, pass in the process ID or name as the argument: ${script_name} [pid | process_name]"

    } >&2
}

# =========================================

# this count is incremented every time a pid is monitored for a timeout 
NUM_TIMEOUT_PROCESSES=0

add_timeout_pid (){
    # $1 is the pid, $2 is the timeout in seconds

    # store the pid we want to watch
    eval TIMEOUT_PID_ARRAY_$NUM_TIMEOUT_PROCESSES=$1
    eval export TIMEOUT_PID_ARRAY_$NUM_TIMEOUT_PROCESSES

    # store the associated timeout
    eval TIMEOUT_TIME_ARRAY_$NUM_TIMEOUT_PROCESSES=$2
    eval export TIMEOUT_TIME_ARRAY_$NUM_TIMEOUT_PROCESSES

    NUM_TIMEOUT_PROCESSES=$(expr $NUM_TIMEOUT_PROCESSES '+' 1)
}

timeout(){
    TIMEOUT_TIMER=0; # current time spent waiting for processes to finish up
    TIMEOUT_REFRESH_INTERVAL=2; # number of seconds between checking for remaining processes

    LIVING_TIMEOUT_PROCESSES=$NUM_TIMEOUT_PROCESSES;

    while [ $LIVING_TIMEOUT_PROCESSES -gt 0 ] ; do
    
        LIVING_TIMEOUT_PROCESSES=0;

        COUNTERB=0; # counter variable for while loop
        while [ $COUNTERB -lt $NUM_TIMEOUT_PROCESSES ] ; do
            # check if the process is still running
            ${PS} ax -o pid | ${GREP} -q $(eval echo "$"TIMEOUT_PID_ARRAY_$COUNTERB)
            DEAD=$?;
            # grab the associated timeout
            TIMEOUT=$(eval ${ECHO} "$"TIMEOUT_TIME_ARRAY_$COUNTERB);

            if [ "$DEAD" -eq "0" ] && [ $TIMEOUT_TIMER -lt $TIMEOUT ] ;
            then
                # if it is still running and has more time left, just count it
                LIVING_TIMEOUT_PROCESSES=$(expr $LIVING_TIMEOUT_PROCESSES '+' 1)
            elif [ "$DEAD" -eq "0" ] && [ $TIMEOUT_TIMER -ge $TIMEOUT ] ;
            then
                # if it is still running and is out of time, don't count it and kill the process
                ${KILL} $(eval ${ECHO} "$"TIMEOUT_PID_ARRAY_$COUNTERB)
            fi

            COUNTERB=$(expr $COUNTERB '+' 1)
        done

        # give the living processes more time to finish up
        if [ $LIVING_TIMEOUT_PROCESSES -gt 0 ] ; then
            ${SLEEP} $TIMEOUT_REFRESH_INTERVAL
            TIMEOUT_TIMER=$(expr $TIMEOUT_TIMER '+' $TIMEOUT_REFRESH_INTERVAL)
        fi
    done
}

# =========================================

includes_perfdiagnose=$( ${ECHO} "${0}" | ${GREP} -e "perfdiagnose" )
if [[ $includes_perfdiagnose = "" ]]
then
  script_name="sysdiagnose"  
fi

# Check that this is the only instance of perfdiagnose running
perfdiagnose_instances=$( ${PS} axw | ${GREP} -e "/bin/sh .*${script_name}" | ${GREP} -v grep | ${SORT} | ${AWK} '{print $1}' )
number_of_perfdiagnose_instances=$( ${ECHO} ${perfdiagnose_instances} | ${WC}  | ${AWK} '{print $2}' )
first_instance_of_perfdiagnose=$( ${ECHO} ${perfdiagnose_instances} | ${AWK} '{print $1}' )

# The below statement is misleading. We only allow *one* instance of perfdiagnose to run at a time.
# With shell scripting, variable assignment to "number_of_perfdiagnose_instances" results in spawning of another perfdiagnose process.
# Consequently, if we are the only perfdiagnose process running, the above statement will find *two* processes with the "perfdiagnose" signature.
most_perfdiagnose_pids_allowed=2
if [ ${number_of_perfdiagnose_instances} -gt ${most_perfdiagnose_pids_allowed} ] && [ $$ -ne ${first_instance_of_perfdiagnose} ]; then 
    ${ECHO} "Error: a previously spawned ${script_name} is still running!"
    exit 1
fi

check_sudo $@

# For *non* stackshot mode
# =========================================
if [ "$1" != "-s" ]
then
    if [[ $# -gt 5 ]]
    then
        usage
    fi
    while getopts 'hf:wt' OPTION
    do
    case $OPTION in
    h)  usage
        ;;
    f)	set_output_directory $OPTARG
        ;;
    w)	TOOL_MODE=1
        ;;
    t)  THOROUGH_MODE=1
        ;;
    ?)	usage
        ;;
    esac
    done
    shift $(($OPTIND - 1))
    process_identifier="$1"
# For stackshot mode. Stackshot mode has to be invoked with -s flag
# =========================================
else
    STACKSHOT_MODE=1
    symstack_args=""
    # Beware of the two seperate -w options. One to ruby and the second to symstacks
    #   - The first -w option is passed to RUBY to turn warnings on when running SYMSTACKS.
    #   - The second -w option is passed to SYMSTACKS to specify the output file (and we catch it here).
    while getopts 'sw:a:o:f:k:' OPTION
    do
    case $OPTION in
    s)  if [ $# -eq 1 ] #If there is only one argument, than we are invoked from the command line.
        then 
            QUICK_MODE=1 
        fi 
            ;;
    w)	symtrace_file="$OPTARG" #Intercept the -w intended for SYMSTACKS (second -w option, see above)
            ;;
    ?)	symstack_args="${symstack_args} -${OPTION} ${OPTARG}"
            ;;
    esac
    done
    # First -w option (see above)
    symbolication_command="${RUBY} -w ${SYMSTACKS}${symstack_args}"
    # We need to make it explicit that no process name or PID were passed in 
    process_identifier=""

    if [ -f "/var/tmp/.thoroughsysdiagnose" ]
    then
        THOROUGH_MODE=1
    fi

# =========================================
fi
# =========================================

if [ ${TOOL_MODE} -eq 0 ] && [ ${STACKSHOT_MODE} -eq 0 ] 
then
    legal
    "${READ}"
fi

# Encourage the user to pass in the "villain" process name or pid
if [[ $# -eq 0 ]] || [[ $# -eq 2 ]]
then
    suggestion
fi

pid=""
process_name=""
data_directory_name="${script_name}"

current_date=`"${DATE}" "+%Y.%m.%d_%H-%M-%S-%Z"`
data_directory_name="${data_directory_name}_${current_date}"

# If the argument is a number, then the user passed in a PID. If the argument is a string, then the user passed in a process name.
if [ "${process_identifier}" != "" ]
then
	PROCESS_MODE=1
	input_first_char=$( "${ECHO}" "${process_identifier}" | "${HEAD}" -c 1 ) 
	if [[ "${input_first_char}" == [0-9] ]]
	then
		pid="${process_identifier}"
	else
		process_name="${process_identifier}"
	fi
fi

# If the user passed in a process name, we need to discover the PID
if [ "${process_name}" != "" ]
then
    pids=`${PS} axc | ${EGREP} -i "${process_name}$" | ${SORT} -r | "${AWK}" '{ print $1}'`
    number_of_pids=$( ${ECHO} ${pids} | ${WC}  | ${AWK} '{print $2}' )
    pid=$( ${ECHO} ${pids} | ${AWK} '{print $1}' )

    if [ ${number_of_pids} -gt 1 ] ; then 
        ${ECHO} "WARNING: multiple processes found with the name ${process_name}. Targeting the process with the highest process ID of ${pid}."
    fi

    if [ "${pid}" = "" ]
    then
        "${ECHO}" "WARNING: no process found for the process name passed in."
    else
        data_directory_name="${data_directory_name}_${process_name}"
    fi
fi

# Extend the result directory name to reflect the PID.
if [ ${PROCESS_MODE} -eq 1 ]
then
	data_directory_name="${data_directory_name}_${pid}"
fi

#make sure data directory does not contain spaces
data_directory_name=`${ECHO} "${data_directory_name}" | ${TR} " " "_"`

data_directory_path="${temp_directory}${data_directory_name}"
tools_output="${data_directory_path}/error_log.txt"

# Create a temporary directory
"${RM}" -rf ${data_directory_path}
"${MKDIR}" ${data_directory_path}
 
#Start data collection:
"${ECHO}" "Gathering time sensitive information"
"${ECHO}" "===================================="

TRACE_DURATION=9

# Take a spindump, fs_usage and top simultaneously
# Need to be root for fs_usage, spindump, kill
"${PS}" auxwww &> ${data_directory_path}/ps_aux.txt

if [[ ${THOROUGH_MODE} -eq 1 ]];
then
    "${ECHO}" "Running trace, spindump and top"
else
    "${ECHO}" "Running fs_usage, spindump and top"
fi

"${SPINDUMP}" ${pid} -file ${data_directory_path}/spindump.txt >> ${tools_output} 2>&1 &
spindump_pid=$!

if [[ ${THOROUGH_MODE} -eq 1 ]];
then
    "${TRACE}" -L ${data_directory_path}/rawtrace -S "${TRACE_DURATION}" >> ${tools_output} 2>&1 &
    trace_pid=$!
else
    "${FS_USAGE}" -w &> ${data_directory_path}/fs_usage.txt &
fi

"${TOP}" -l"${TRACE_DURATION}" -d -r -o rprvt &> ${data_directory_path}/top.txt
# top blocks for its duration, so we don't need a sleep here

if [ ${THOROUGH_MODE} -eq 1 ]
then
    wait "${trace_pid}"
    "${FS_USAGE}" -R ${data_directory_path}/rawtrace -w &> ${data_directory_path}/fs_usage.txt
else
    "${KILLALL}" fs_usage
fi

"${KILL}" ${spindump_pid} >> ${tools_output} 2>&1

"${ECHO}" "  "
"${ECHO}" "Done gathering time sensitive information. Proceeding to gather non time sensitive data"
"${ECHO}" "======================================================================================="

# Gather simple diskutil list
({ "${DISKUTIL}" list ; echo "\n*********************\n"; } > ${data_directory_path}/diskutil.txt

# Gather info for each disk/volume found -- this is the long pole of data gathering
"${DISKUTIL}" list | "${GREP}" -E "[ \t]+disk" | "${GREP}" -o -E "disk.*$" |
		"${XARGS}" -I {} "${SH}" -c " '${DISKUTIL}' info {} ; echo '*********************\n' " >> ${data_directory_path}/diskutil.txt &

# Get GPT info for each GPT volume
"${DISKUTIL}" list | "${GREP}" GUID_partition_scheme | "${GREP}" -o -E "disk[0-9]+" |
		"${XARGS}" -I {} "${SH}" -c " '${GPT}' -rvvvv show /dev/{} ; echo '\n*********************\n' " >${data_directory_path}/gpt.txt 2>&1
)&
add_timeout_pid $! 30

# Run zprint
"${ECHO}" "Running zprint"
"${ZPRINT}" -t -w &> ${data_directory_path}/zprint.txt

"${SYSCTL}" -a &> ${data_directory_path}/sysctl.txt

# Lets take a look at kexts
"${ECHO}" "Running kextstat"
"${KEXTSTAT}" &> ${data_directory_path}/kextstat.txt

# Create the log directories
log_directory="${data_directory_path}/logs"
"${MKDIR}" ${log_directory}

shutdown_log_directory="${log_directory}/shutdown"
"${MKDIR}" ${shutdown_log_directory}

# Get shutdown logs
"${CP}" "-R" "-p"  /var/log/com.apple.launchd* "${shutdown_log_directory}"/ 2>> ${tools_output}

# Get current state information from opendirectoryd
# Killalll is to dump detailed internal state information to that the opendirectoryd.log file
"${KILLALL}" -INFO opendirectoryd
"${ODUTIL}" show all &> ${data_directory_path}/odutil.txt
copy_files_if_present "/var/log/opendirectoryd.log*" ${log_directory}

# If CGDebug exists, gather information about open windows on the system
if [ -f "${CGDEBUG}" ]
then
    "${ECHO}" "Running CGDebug -winfo"
    "${CGDEBUG}" -winfo &> ${data_directory_path}/cgdebug.txt &
    add_timeout_pid $! 10
else
    "${ECHO}" "CGDebug not present. Skipping." >> ${tools_output} 2>&1
fi

if [ -f "${BOOTCACHECONTROL}" ]
then
    "${ECHO}" "Collecting BootCache Statistics"
    "${BOOTCACHECONTROL}" statistics &> ${data_directory_path}/bc_stats.txt
else
    "${ECHO}" "BootCacheControl not present. Skipping." >> ${tools_output} 2>&1
fi

# Get network information
"${ECHO}" "Running netstat"

netstat_directory="${data_directory_path}/netstat"
"${MKDIR}" ${netstat_directory}
"${NETSTAT}" -anW &> ${netstat_directory}/netstat_anW.txt
"${NETSTAT}" -sW &> ${netstat_directory}/netstat_sW.txt
"${NETSTAT}" -mmmW &> ${netstat_directory}/netstat_mmmW.txt
"${NETSTAT}" -indW &> ${netstat_directory}/netstat_indW.txt
"${NETSTAT}" -nralW &> ${netstat_directory}/netstat_nralW.txt
"${NETSTAT}" -rs &> ${netstat_directory}/netstat_rs.txt

/System/Library/PrivateFrameworks/Apple80211.framework/Resources/airport --getinfo &> ${data_directory_path}/airport_info.txt

# Get network interface information
if [ -f "${IFCONFIG}" ]
then
    "${IFCONFIG}" -a -L -b -m -r -v &> ${data_directory_path}/ifconfig.txt 2>&1

    if [ -f "${IPCONFIG}" ]
    then
        for interface in `${IFCONFIG} -l`
        do
            case ${interface} in
            lo* )   ;;
            en* )   "${IPCONFIG}" getpacket ${interface} > ${data_directory_path}/ipconfig-${interface}.txt 2>&1
                    ;;
            esac
        done
    fi
fi

# Get Reachability information
if [ -f "${SCUTIL}" ]
then
    "${SCUTIL}" -d -v -r www.apple.com > ${data_directory_path}/reachability-info.txt 2>&1
fi

if [ -f "${DIG}" ] && [ -f /etc/resolv.conf ] 
then
    "${DIG}" -t any -c any www.apple.com > ${data_directory_path}/dig-results.txt 2>&1
fi

# Get list of opened files
"${ECHO}" "Running lsof"
"${LSOF}" -n -M -P -T -w &> ${data_directory_path}/lsof.txt

# Get DNS environment
"${SCUTIL}" --dns &> ${data_directory_path}/scutil.txt
copy_file_if_present /etc/resolv.conf ${data_directory_path}/etc_resolv.conf
copy_file_if_present /var/run/resolv.conf ${data_directory_path}/var_run_resolv.conf

# Get power management information. If available, use -g everything, otherwise fall back to old calls.
"${ECHO}" "Running pmset diagnostics"
"${PMSET}" -g everything &> ${data_directory_path}/pmset_everything.txt
if [ $? -ne 0 ]
then
    "${RM}" ${data_directory_path}/pmset_everything.txt
    "${PMSET}" -g log &> ${data_directory_path}/pmset.txt
    "${PMSET}" -g assertions &> ${data_directory_path}/pmset_assertions.txt
fi
    
# Only run allmemory when not run under stackshot
# =========================================
if [ ${STACKSHOT_MODE} -ne 1 ] && [ ${THOROUGH_MODE} -ne 1 ]
then
    # Now, lets take a look at memory
    "${ECHO}" "Running allmemory. This will take a couple of minutes"
    # Need to be root for allmemory
    "${ALLMEMORY}" -p -f -purge -v -sections -FD &> ${data_directory_path}/allmemory.txt
fi

if [[ ${THOROUGH_MODE} -eq 1 ]];
then
    # Now, lets take a look at memory
    "${ECHO}" "Running allmemory. This will take a couple of minutes"
    # Need to be root for allmemory
    "${ALLMEMORY}" -n -o ${data_directory_path}/allmemory.amdata 2>> ${tools_output}
fi

# Heap and leaks should be placed after allmemory due to: <rdar://problem/9923558>
# Run process-specific tools (Round 2)
if [ ${PROCESS_MODE} -eq 1 ]
then
    #Check if the ddt executable exists [ddt is not included on customer installs]
    if [ -f "${DDT}" ]
    then
        "${ECHO}" "Running ddt on the process ${pid}"
        #Need to be root
        "${DDT}" -v -k ${pid} &> ${data_directory_path}/ddt.txt
    fi

    #Check if the heap executable exists [heap is not included on older customer installs]
    if [ -f "${HEAP}" ]
    then
        "${ECHO}" "Running heap on the process ${pid}"
        "${HEAP}" ${pid} &>  ${data_directory_path}/heap.txt
        # Run process specific zprint [does not work on customer installs]
    fi
    if [ -f "${VMMAP}" ]
    then
    
        "${ECHO}" "Running vmmap on the process ${pid}"
        "${VMMAP}" -resident -dirty -purge ${pid} &> ${data_directory_path}/vmmap.txt
    fi
    #Check if the leaks executable exists [leaks is not included on older customer installs]
    if [ -f "${LEAKS}" ]
    then
        "${ECHO}" "Running leaks on the process ${pid}"
        # Need to be root
        "${LEAKS}" -nocontext ${pid} &> ${data_directory_path}/leaks.txt
    fi
    "${ECHO}" "Running zprint on the process ${pid}"
    # Need to be root
    "${ZPRINT}" -t -w -p ${pid} &> ${data_directory_path}/zprint-${pid}.txt
fi

# Grab system profile
system_profiler_data_types=( "SPParallelATADataType" "SPAirPortDataType" "SPBluetoothDataType" "SPDiagnosticsDataType" "SPEthernetDataType"\
                             "SPExtensionsDataType" "SPFibreChannelDataType" "SPFireWireDataType" "SPFirewallDataType" "SPHardwareDataType"\
                             "SPHardwareRAIDDataType" "SPNetworkLocationDataType" "SPManagedClientDataType" "SPMemoryDataType" "SPNetworkDataType"\
                             "SPPowerDataType" "SPSerialATADataType" "SPSoftwareDataType" "SPUSBDataType" "SPNetworkVolumeDataType" "SPExtensionsDataType" "SPDisplaysDataType" )
if [ ${STACKSHOT_MODE} -eq 1 ]
then
    system_profiler_data_types=( "SPAirPortDataType" "SPHardwareDataType" "SPMemoryDataType" "SPNetworkDataType"\
                                 "SPSerialATADataType" "SPSoftwareDataType" "SPDisplaysDataType" )
fi

system_profiler_arguments=("${system_profiler_data_types[*]}")
"${ECHO}" "Running system profiler"
"${SYSTEM_PROFILER}" ${system_profiler_arguments[0]} -xml &> ${data_directory_path}/system_profiler.spx &
add_timeout_pid $! 120

# Grab the logs
# Need to be root to grab the logs
"${ECHO}" "Copying kernel and system logs"

copy_files_from_directory_if_present /var/log "kernel.log system.log secure.log windowserver.log install.log zzz.log" ${log_directory} 
copy_dir_if_present /var/log/DiagnosticMessages ${data_directory_path}

# Collect preferences
pref_directory="/Library/Preferences"
from_config_directory="${pref_directory}/SystemConfiguration"
to_config_directory="${data_directory_path}/SystemConfiguration"
copy_dir_if_present ${from_config_directory}/CaptiveNetworkSupport ${to_config_directory}

copy_files_from_directory_if_present ${from_config_directory} "NetworkInterfaces.plist com.apple.Boot.plist com.apple.PowerManagement.plist com.apple.airport.preferences.plist \
com.apple.network.eapolclient.configuration.plist com.apple.network.identification.plist com.apple.smb.server.plist preferences.plist preferences.plist.old com.apple.nat.plist \
com.apple.wifi.plist bootpd.plist com.apple.named.proxy.conf" ${to_config_directory}

copy_files_from_directory_if_present ${pref_directory} "com.apple.alf.plist com.apple.sharing.firewall.plist com.apple.wwand.plist"  ${to_config_directory}

copy_files_from_directory_if_present /etc "bootpd.plist com.apple.name.proxy.conf" ${to_config_directory}


# Grab spin and crash reports for the current build
"${ECHO}" "Copying spin and crash reports"
crash_and_spin_directory="${data_directory_path}/crashes_and_spins"
diagnostic_reports="/Library/Logs/DiagnosticReports"
"${MKDIR}" ${crash_and_spin_directory}
current_build=$( "${SW_VERS}" -buildVersion )
if [ -d  "${diagnostic_reports}" ]
then
    copy_reports_for_current_build ${diagnostic_reports} ${crash_and_spin_directory} $current_build
fi

# Get the user name of the currently logged in user in order to find the rest of the Diagnostic Reports
current_users=$( "${WHO}" | ${AWK} '{print $1}' )
first_user=$( ${ECHO} ${current_users} | ${AWK} '{print $1}' )
user_diagnostic_reports="/Users/${first_user}${diagnostic_reports}"
if [ -d  "${user_diagnostic_reports}" ]
then
    copy_reports_for_current_build ${user_diagnostic_reports} ${crash_and_spin_directory} $current_build
fi

# Get disk information
"${ECHO}" "Running df"
disk_info_file="${data_directory_path}/disks.txt"
"${PRINTF}" "#df\n" >> ${disk_info_file}
"${DF}" -H >> ${disk_info_file} 2>&1

copy_file_if_present /var/log/fsck_hfs.log ${data_directory_path}/fsck_hfs_var.log
copy_file_if_present /Users/${first_user}/Library/Logs/fsck_hfs.log ${data_directory_path}/fsck_hfs_user.log

"${ECHO}" "Running ioreg"
# Get IOKit registry information
ioreg_directory="${data_directory_path}/ioreg"
"${MKDIR}" ${ioreg_directory}
("${IOREG}" -i -l -p IOService -w 0 &> ${ioreg_directory}/IOService.txt
"${IOREG}" -i -l -p IOACPIPlane -w 0 &> ${ioreg_directory}/IOACPIPlane.txt
"${IOREG}" -i -l -p IOPower -w 0 &> ${ioreg_directory}/IOPower.txt
"${IOREG}" -i -l -p IODeviceTree -w 0 &> ${ioreg_directory}/IODeviceTree.txt
"${IOREG}" -i -l -p IOUSB -w 0 &> ${ioreg_directory}/IOUSB.txt
"${IOREG}" -i -l -p IOFireWire -w 0 &> ${ioreg_directory}/IOFireWire.txt ) &
add_timeout_pid $! 30

# Get mount information
"${MOUNT}" &> ${data_directory_path}/mount.txt

# Get resume info
"${TALAGENT}" -log &> ${log_directory}/talagent.log

# Create a tarball of the results and clean up
cd ${temp_directory}

# Spindump has likely exited here, but explicitly wait for spindump to finish
# Wait for diskutil to finish
wait "${spindump_pid}"

# give long running background processes a chance to complete
timeout

# Need to be root to create the tar ball
tar_ball="${data_directory_name}.tar.gz"
tar_ball_path="${temp_directory}${tar_ball}"
"${TAR}" -czf ${tar_ball} ${data_directory_name}
"${RM}" -rf ${data_directory_path}

"${ECHO}" "${script_name} results written to ${tar_ball_path}"

# Only pop up the Finder window if we are not in tool mode
if [ ${TOOL_MODE} -eq 0 ]
then

IFS="/"
set -- ${tar_ball_path}
arr=( ${tar_ball_path} )
osascript_tar_ball_path=""
first_slash=1
for dir in ${arr[@]}
do
    if [ ${first_slash} -eq 1 ]
    then
        first_slash=0
    else
        osascript_tar_ball_path="${osascript_tar_ball_path}:${dir}"
    fi
done

# Reveal the result in Finder
# Redirect osascript errors to /dev/null. These errors usually have the form "execution error: ..." Consequently, they often lead the user to think that sysdiagnose experienced a fatal error.
# The tar ball result has already been created, so appending these errors to the error log is not possible.
"${OSASCRIPT}" << EOT &> "${NULL}"
tell application "Finder"
reveal { ¬
item "${osascript_tar_ball_path}" of startup disk ¬
}
activate
end tell
EOT

IFS=" "
fi

# For stackshot mode (invoked with -s flag)
# =========================================
if [ ${STACKSHOT_MODE} -eq 1 ] && [ ${QUICK_MODE} -eq 0 ]
then
    # Second -w option (see above)
    "${ECHO}" "Symbolicating the stackshot"
    ${symbolication_command} -w "${symtrace_file}"
    "${KEXTSTAT}" >> ${symtrace_file}
fi
# =========================================

exit 0
